import { makeExecutableSchema, addMockFunctionsToSchema, mockServer } from 'graphql-tools';
import { graphql } from 'graphql';
import { typeDefs } from './schema'
import 'babel-polyfill';

const testCaseMyTask = {
  id: 'Test My Tasks',
  query: `
    query {
        Application(urlCaption: "MyTasksSummary", locale: "en-US") {
            caption
            tabs {
              caption
              index
              ... on TabAutoGeneratedView {
                view {
                  id,
                  content
                }
              }
          }
        }
      }
  `,
  variables: {},
  context: {},
  expected: {
    data: {
      Application: {
        caption: 'My Tasks Summary', tabs: [{
          "caption": "My Tasks Summary",
          "index": 1,
        },
        {
          "caption": "My Tasks Summary",
          "index": 1,
        },]
      }
    }
  }
};

describe('Schema', () => {
  // Array of case types
  const cases = [testCaseMyTask];
  const mockSchema = makeExecutableSchema({ typeDefs });

  // Here we specify the return payloads of mocked types
  addMockFunctionsToSchema({
    schema: mockSchema,
    mocks: {
      Boolean: () => false,
      ID: () => '1',
      Int: () => 1,
      Float: () => 12.34,
      String: () => 'My Tasks Summary',
    }
  });

  test('has valid type definitions', async () => {
    expect(async () => {
      const MockServer = mockServer({ typeDefs });

      await MockServer.query(`{ __schema { types { name } } }`);
    }).not.toThrow();
  });

  cases.forEach(obj => {
    const { id, query, variables, context: ctx, expected } = obj;

    test(`query: ${id}`, async () => {
      return await expect(
        graphql(mockSchema, query, null, { ctx }, variables)
      ).resolves.toEqual(expected);
    });
  });

});